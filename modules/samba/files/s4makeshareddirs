#! /usr/bin/perl -w
use strict;
use warnings;
use utf8;
use File::Basename;
use File::Path;
use File::Finder;
use Getopt::Long;
use Sys::Hostname;
use Linux::ACL;
use Data::Dumper;

# output as utf8 #
binmode(STDOUT,':encoding(UTF-8)');

#########
# usage #
#########
sub displayUsage {
   my $callerProgram = basename($0);
   print("usage: $0 [-b baseClass] [-f] [-d]");
   print("   -b : update only dirs belonging to baseClass");
   print("   -f : force updating share permissions");
   print("   -d : delete unused dirs, asking for confirmation");
   exit(0);
}


######################
# check samba config #
######################
my $s4ConfFile = "/etc/samba/s4.conf";

# global vars #
my $samDatabase;
my $baseDN;
my $baseUserDN;
my $baseUserGroup;

my $dfsPath;
my $unixHomePath;
my $homeShare;
my $unixProfilePath;
my $profileShare;
my $unixSharePath;
my $shareShare;

my $baseShareDN;

 
my $studentBaseDN;
my $baseStudentDN;
my $loginSurnameChar;
my $loginGivennameChar;
my $unixHomePath;
my $baseStudentDir;
my $teachersDirName;

# open main configuration file #
open(SCONF, "< $s4ConfFile") or die("Cannot read $s4ConfFile");
while( defined( my $line = <SCONF> ) ) {
   chomp $line;
   
   # remove comments #
   if( $line =~ m/\#/ ) {
      if( $line =~ /(.*?)\#/ ) {
         $line = $1;
      }
   }

   # sam database #
   if ( $line =~ m/samDatabase *= *\"(.*?)\"/ ) {
      $samDatabase = $1;
   }

   # student base dn #
   elsif ( $line =~ m/baseDN *= *\"(.*?)\"/ ) {
      $baseDN = $1;
   }
   elsif ( $line =~ m/baseUserDN *= *\"(.*?)\"/ ) {
      $baseUserDN = $1;
   }
   elsif ( $line =~ m/baseStudentDN *= *\"(.*?)\"/ ) {
      $baseStudentDN = $1;
   }
   elsif ( $line =~ m/baseShareDN *= *\"(.*?)\"/ ) {
      $baseShareDN = $1;
   }

   # base user group #
   elsif ( $line =~ m/baseUserGroup *= *\"(.*?)\"/ ) {
      $baseUserGroup = $1;
   }

   # directory structure #
   elsif ( $line =~ m/dfsPath *= *\"(.*?)\"/ ) {
      $dfsPath = $1;
   }
   elsif( $line =~ m/unixHomePath *= *\"(.*?)\"/ ) {  
      $unixHomePath = $1;
   }
   elsif( $line =~ m/homeShare *= *\"(.*?)\"/ ) {
      $homeShare = $1;
   }
   elsif( $line =~ m/unixProfilePath *= *\"(.*?)\"/ ) {
      $unixProfilePath = $1;
   }
   elsif( $line =~ m/profileShare *= *\"(.*?)\"/ ) {
      $profileShare = $1;
   }
   elsif( $line =~ m/unixSharePath *= *\"(.*?)\"/ ) {
      $unixSharePath = $1;
   }
   elsif( $line =~ m/shareShare *= *\"(.*?)\"/ ) {
      $shareShare = $1;
   }

   # login surname part #
   elsif ( $line =~ m/loginSurnameChar *= *\"(.*?)\"/ ) {
      $loginSurnameChar = $1;
   }

   # login givenname part #
   elsif ( $line =~ m/loginGivennameChar *= *\"(.*?)\"/ ) {
      $loginGivennameChar = $1;
   }

   # unix home path #
   elsif ( $line =~ m/unixHomePath *= *\"(.*?)\"/ ) {
      $unixHomePath = $1;
   }

   # base students directory #
   elsif ( $line =~ m/baseStudentDir *= *\"(.*?)\"/ ) {
      $baseStudentDir = $1;
   }

   # teacher shared directory name  #
   elsif ( $line =~ m/teachersDirName *= *\"(.*?)\"/ ) {
      $teachersDirName = $1;
   }

}
close(SCONF);

# check global vars #
if( ! (defined($samDatabase) &&
       defined($baseDN) &&
       defined($baseUserDN) &&
       defined($baseStudentDN) &&
       defined($loginSurnameChar) &&
       defined($loginGivennameChar) ) ) {
   print("Cannot read global variables on $s4ConfFile\n");
   exit(0); 
} else {
   $studentBaseDN = "$baseStudentDN,$baseDN";
}


###########################
# uid/gid mapping library #
###########################

# store name => id #
my %usersUid;
my %groupsGid;
my %sharesGid;

# get all classic users uids #
open(my $ldbCall, "-|", "s4ldbsearch $baseUserDN,$baseDN sub user '()' uidNumber");

while( my $userInfoLine = <$ldbCall> ) {

   chomp($userInfoLine);

   my @userInfo = split(/\t/, $userInfoLine);
   if( defined($userInfo[1]) ) {
      if( $userInfo[0] =~ m/^CN=(.*?),/ ) {
         my $userName = $1;
         my $userUid = $userInfo[1];
         $usersUid{$userName} = $userUid;
      }
      else {
         print("Error getting user uid !\n");
         exit(1);
      }
   }
}

close($ldbCall);

# get all classic groups gids #
open($ldbCall, "-|", "s4ldbsearch $baseUserDN,$baseDN sub group '()' gidNumber");

while( my $groupInfoLine = <$ldbCall> ) {

   chomp($groupInfoLine);

   my @groupInfo = split(/\t/, $groupInfoLine);
   if( defined($groupInfo[1]) ) {
      if( $groupInfo[0] =~ m/^CN=(.*?),/ ) {
         my $groupName = $1;
         my $groupGid = $groupInfo[1];
         $groupsGid{$groupName} = $groupGid;
      }
      else {
         print("Error getting group gid !\n");
         exit(1);
      }
   }
}

close($ldbCall);


# get all classic share gids #
open($ldbCall, "-|", "s4ldbsearch $baseShareDN,$baseDN sub user '()' gidNumber");

while( my $shareInfoLine = <$ldbCall> ) {

   chomp($shareInfoLine);

   my @shareInfo = split(/\t/, $shareInfoLine);
   if( defined($shareInfo[1]) ) {
      if( $shareInfo[0] =~ m/^CN=(.*?),/ ) {
         my $shareName = $1;
         my $shareGid = $shareInfo[1];
         $sharesGid{$shareName} = $shareGid;
      }
      else {
         print("Error getting share gid !\n");
         exit(1);
      }
   }
}

close($ldbCall);



sub getUserUid {

   # get params, the user name #
   my $userName = $_[0];

   # check if we have the uid #
   if( defined($usersUid{$userName}) {
      return $usersUid{$userName};
   } else {

      # try to find the user #
      open(my $ldbCall, "-|", "s4ldbsearch $baseDN sub user \"(cn=$userName)\" uidNumber");
      my $userInfoLine;

      while( $userInfoLine = <$ldbCall> ) { }
      close($ldbCall)

      # check if user found #
      if( $? != 0 ) {
         return -1;
      } else {

         # save the result #
         my $userUid = (split(/\t/, $userInfoLine))[1];
         $usersUid{$userName} = $userUid;
         return $userUid;
      }
   }
}


sub getGroupGid {

   # get params, the group name #
   my $groupName = $_[0];

   # check if we have the gid #
   if( defined($usersUid{$userName}) {
      return $usersUid{$userName};
   } else {

      # try to find the user #
      open(my $ldbCall, "-|", "s4ldbsearch $baseDN sub user \"(cn=$userName)\" uidNumber");
      my $userInfoLine;

      while( $userInfoLine = <$ldbCall> ) { }
      close($ldbCall)

      # check if user found #
      if( $? != 0 ) {
         return -1;
      } else {

         # save the result #
         my $userUid = (split(/\t/, $userInfoLine))[1];
         $usersUid{$userName} = $userUid;
         return $userUid;
      }
   }
}


###############
# ask library #
###############

sub askYesOrNo {

   # get params, the questions #
   my $question = $_[0];

   # ask #
   while( 1 ) {
      print("$question ([y]es or [N]o): ");
      my $rep = <>;
      if( $rep =~ /^y(es|)$/ ) {
         return 'yes';
      elsif( $rep =~ /^no?$/ ) {
         return 'no';
      }
   }
}


##############
# parse args #
##############

# the options #
my $optBaseClass;
my $optForce;
my $optDelete;

Getopt::Long::Configure("bundling","no_ignore_case");
GetOptions("b|base-class" => \$optBaseClass,
           "f|force" => \$optForce,
           "d|delete" => \$optDelete) 
          or displayUsage();

# check args #
if( @ARGV != 0 ){
   displayUsage();
}


# check the delete option #
# can be combined with base class as we touch each dircetory #
# to check unused dirs #
if ( defined($optBaseClass) && defined($optDelete) ) {
   print("The -b and -d options can't be used together.\n");
   exit(1);
}


# get the base class #
my $baseClassName;

if ( ! defined($optBaseClass) ) {
   $baseClassName = substr($baseUserDN, length('OU='));
} else {
   $baseClassName = $optBaseClass;
}

# check the class exist #
my $baseClassGroup;

open(my $classCheckCall, "-|", "s4classcheck $baseClassName");
while( my $classInfoLine = <$classCheckCall> ) {
   if( $classInfoLine =~ m/Class group: (.*)$/ ) {
      $baseClassGroup = $1;
   }
   elsif( $classInfoLine =~ m/Class DN: (.*)$/ ) {
      $baseClassUserDN = $1;
   }
   elsif( $classInfoLine =~ m/Class share DN: (.*)$/ ) {
      $baseClassShareDN = $1;
   }
}

close($classCheckCall);
if( $? != 0 ) {
   print("Cannot find base class $baseClassName !\n");
   exit(1);
}

###################
# get system vars #
###################

# get hostname #
my $hostname = hostname;

# get time #
my $baseTimestamp = time();


# update dir timestamp and return if #
# the dir must be updated            #
sub touchDir {
   if ( -e $1 ) {
      utime(undef, undef, $1);
      if ( defined($optForce) ) {
         return 1;
      } else {
         return 0;
      }
   } else {
      make_path($1);
      return 1;
   }
}

####################
# create user dirs #
####################

# save remote server #
my %remoteHomeServers;

# home directories that need to be deleted later #
my @oldHomeDirs;

# get all users #
open($ldbCall, "-|", "s4ldbsearch $baseClassUserDN,$baseDN sub user '()' cn unixHomeDirectory uidNumber gidNumber");

while( my $userInfoLine = <$ldbCall> ) {

   # get user info #
   my ($userDn, $userName, $userHomeDirectory, $userUid, $userGid) = split(/\t/, $userInfoLine);

   # get user class group #
   if( $userDn =~ m/CN=$userCn,OU=(.*?),/ ) {
      $userClassGroup = lc($1);
   } else {
      print("Cannot determine user $userCn class group !\n");
      exit(1);
   }

   # get user server #
   my $userServer;
   if( $userHomeDirectory =~ m/\/dnfs\/$homeShare\/(.*)\/$userName ) {
      $userServer = $1;
   } else {
      print("Cannot determine user $userCn home server !\n");
      exit(1);
   }

   ####################
   # create user dirs #
   ####################

   # make class directory #
   touchDir("/srv/nfs4/$shareShare/$userClassGroup");
   touchDir("$dfsPath/$userClassGroup");

   # if user on current server create user directory #
   if ( $userServer eq $serverHostname ) {

      #############################
      # check some specials cases #
      #############################
      if ( -e $unixHomePath/$userName ) {

         # check if the uid is correct #
         my ($currentDirUid, $currentDirGid) = (stat($unixHomePath/$userName))[4,5];

         if ( $currentDirUid != $userUid) {

            # bad uid ! this must be an old user dir, delete or restore #
            push @oldHomeDirs, $unixHomePath/$userName;
            chown($userUid, $userGid, $unixHomePath/$userName);
            system("setfacl -bk $unixHomePath/$userName");
            chmod(0700, $unixHomePath/$userName);

         } else {

            # check if the gid is correct #
            if ( $currentDirGid != $userGid ) {

                # bad gid ! may the user's class have changed #
                print("Seems the ${userName}'s class have changed, restoring rights ...\n");
                chown($userUid, $userGid, $unixHomePath/$userName);
                system("setfacl -bk $unixHomePath/$userName");
                chmod(0700, $unixHomePath/$userName);
            }
         }
      }      

      # touch the directory, and update rights if force #
      if( ! touchDir($unixHomePath/$userName) ) {

            chown($userUid, $userGid, $unixHomePath/$userName);
            system("setfacl -bk $unixHomePath/$userName");
            chmod(0700, $unixHomePath/$userName);
      }
   }

   # if the user is not on this server, add to the remote servers list #
   else {
      $remoteHomeServers{$userServer} = 1;
   }
}

close($ldbCall);


##################
# get nfs params #
##################

# get template #
open(my $exportTemplate, "<", "/etc/exports.d/export.template") or die("Cannot find nfs export template !\n");
my $shareNfsTemplate = <$exportTemplate>;
close($exportTemplate);

# extract params #
my $shareNFSParams = (split(" ", $shareNfsTemplate))[1];


######################################
# create nfs home server redirection #
######################################
foreach my $remoteHomeServer (keys @remoteHomeServers) {

   my $serverHomeShareDir="/srv/nfs4/$homeShare/$remoteHomeServer";

   # create directory #
   touchDir($serverHomeShareDir)
   chown(0, $baseUserGroup, $serverHomeShareDir);
   chmod(0777, $serverHomeShareDir);

   # create systemd unit #
   my $systemdUnitName="srv-nfs4-$homeShare-$remoteHomeServer.mount";
   open(my $systemdUnit, ">", $systemdUnitName) or die "Can't open $systemdUnitName !";

   print $systemdUnit 
"[Unit]

[Mount]
What=$serverHomeShareDir
Where=$serverHomeShareDir
Type=none
Options=bind

[Install]
WantedBy=multi-user.target
";

   close($systemdUnit);

   system("systemctl enable $systemdUnitName");
   system("systemctl start $systemdUnitName");

   ###########################
   # create nfs4 redirection #
   ###########################

   # add new referral params #
   $shareNFSParamsWithReferral = substr($shareNFSParams, 0, -1) . ",refer=/$homeShare/$remoteHomeServer@$remoteHomeServer)");
   
   # create new share #
   open($nfsShareExport, ">", "/etc/exports.d/home-redirection-$remoteHomeServer.exports");
   print $nfsShareExport "$serverHomeShareDir $shareNFSParamsWithReferral";
   close($nfsShareExport);

}


######################
# create shares dirs #
######################

# get all shares #
open($ldbCall, "-|", "s4ldbsearch $baseClassShareDN,$baseDN sub user '()' cn givenName description unixHomeDirectory memberOf");

while( my $shareInfoLine = <$ldbCall> ) {

   # get share info #
   # givenName -> show name
   # description -> rights owner,mod,acls
   # unixHomeDirectory -> server 
   # memberOf -> the classes that see the share  
   my ($shareDN, $shareName, $shareShowName, $shareRights, $shareServer, $shareShowClassesList) = split(/\t/, $shareInfoLine);

   # get share class group and DN #
   my $shareClassName;
   my $shareClassGroup;
   my $shareClassGroupDN;

   if( $shareDN =~ m/CN=$shareName,OU=(.*?),(.*),$baseShareDN,$baseDN$/ ) {
      $shareClassName = $1;
      $userClassGroup = lc($shareClassName);
      $shareClassGroupDN = "CN=$userClassGroup,OU=$shareClassName,$2,$baseUserDN,$baseDN";
   } else {
      print("Cannot determine the share $shareName class group !\n");
      exit(1);
   }

   # get share class display name #
   my $shareClassDisplayName;

   open(my $searchGroupCall , "-|", "s4ldbsearch $shareClassGroupDN base group '()' displayName)
   my $shareClassGroupInfoLine = <$searchGroupCall>;
   my $shareClassDisplayName = (split(/\t/, <$searchGroupCall>))[1];
   close($searchGroupCall);

   if ( $? != 0 ) {
      print("Cannot find $shareClassGroupDN !\n");
      exit(1);
   }

   # get share show classes #
   my @shareShowClasses = split(/|/, $shareShowClassesList);

   # get rights #
   my (shareOwner,shareMod,shareAcls) = split(/,/, $shareRights);
   

   ##############
   # get rights #
   ##############

   my (shareOwnerUser, shareOwnerGroup) = split(/:/, $shareOwner);

   my $shareOwnerUID;
   if( $shareOwnerUser eq 'root' ) {
      $shareOwnerUID = 0;
   } else {
      $shareOwnerUID = getUserUid($shareOwnerUser);
   }

   my $shareOwnerGID;
   if( $shareOwnerGroup eq 'root' ) {
      $shareOwnerGID = 0;
   } else {
      $shareOwnerGID = getGroupGid($shareOwnerGroup);
   }



   ############################
   # create share directories #
   ############################
   if( $hareServer eq $serverHostname ) {

      # check share directory #
      if( ! touchDir($unixSharePath/$shareName) ) {

         chown($shareOwnerUID, $shareOwnerGID, $unixSharePath/$shareName)
         chmod($shareMod, $unixSharePath/$shareName);
         system("setfacl -bk $unixSharePath/$shareName");
         #!!!
         if( $shareAcls ) {
            system("setfacl -m $shareAcls $unixSharePath/$shareName");
         }
      }
   }


   ########################
   # create nfs/dfs links #
   ########################
   unlink("/etc/exports.d/$shareName.exports")

   my $nfsDFSRoot = "/srv/nfs4/$shareShare";
   my $sambaDFSRoot = "$dfsPath";

   foreach my $showClass (@shareShowClasses) {

      # make dirs #
      # the nfs one and samba dfs one # 
      my $shareShowDir = "$nfsDFSRoot/" . lc($showClass) . "/$shareClassDisplayName/$shareShowName";
      my $sambaShareShowDir = "$sambaDFSRoot/" . lc($showClass) . "/$shareClassDisplayName/$shareShowName"";

      touchDir($shareShowDir);
      touchDir($sambaShareShowDir);

      # nfs share #
      my $shareNfs = "$shareShowDir $shareNFSParams"
      my $systemdUnitName = $shareShowDir;
      $systemdUnitName =~ s|/|-|g;
      
      # add referral if needed #
      my $mountTarget;
      if( $shareServer eq $serverHostname ) {
         $mountTarget = "$unixSharePath/$shareName";
      } else {
         # bin mount to itself #
         $mountTarget = $shareShowDir;
         $shareNfs = substr($shareNfs, 0, -1) . ",refer=/$shareShare/${showClass,,}/$shareClassDisplayName/$shareShowName@$shareServer\)"; 
      }

      # write unit file #
      open(my $unitFile, ">", "/lib/systemd/system/$systemdUnitName");
      print $unitFile
"[Unit]

[Mount]
What=$mountTarget
Where=$shareShowDir
Type=none
Options=bind

[Install]
WantedBy=multi-user.target
";

   system("systemctl enable $systemdUnitName");
   system("systemctl start $systemdUnitName");
   
   # add show export #
   open(my $shareExport, ">>", "/etc/exports.d/$shareName.exports");
   print $shareExport "$shareNfs\n";
   close($shareExport);

   # dfs share #
   symlink("msdfs:$shareServer\\$shareShare\\$shareName", $sambaShareShowDir); 
}

# reload nfs #
system("/usr/sbin/exportfs -ra");

#---------------------------------------------------

###################
# clean if needed #
###################

# old user dirs #
foreach my $oldHomeDir (@oldHomeDirs) {

   my changedUserName = basename($oldHomeDir);
   my ($changedUserUid, $changedUserGid) = (stat($oldHomeDir))[4,5];
   print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
   print("$oldHomeDir seems to be an old home dir.\n");
   print("But a new user with the same name now exist.\n");
   if( askYesOrNo("Would you like to delete the old files ? if not they will be given to the new user.") eq "yes" ) {
      unlink($oldHomeDir);
      touchDir($oldHomeDir);
      chown($changedUserUid, $changedUserGid, $oldHomeDir);
      chmod(0700, $oldHomeDir);
   } else {
      chown($changedUserUid, $changedUserGid, File::Finder->in($oldHomeDir));
      chmod(0700, $oldHomeDir);
      system("setfacl -R -bk $oldHomeDir");
   }
   print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
}


# the others dirs #
if( $optDelete ) {

   # clean homes dirs #
   my @badHomeDirs;
   
   # check all homes #
   foreach my $homePath (<$unixHomePath/*>) {

      # check if the directory is older #
      if ( (stat($homePath))[9] < $baseTimestamp ) {
         push @badHomeDirs, $homePath;
      }
   }

   if( @badHomeDirs ) {

      print("\n");
      print("###############################################\n");
      print(" The following home directories seems not used \n");
      print("###############################################\n");

      foreach my $badHomeDir (@badHomeDirs) {
         print("$badHomeDir\n");
      }

      if( askYesOrNo("Would you like to delete them ?") eq "yes") {
         


      if [ $(ask_yes_or_no "Would you like to delete them ?") == "yes" ]; then
         for badHomeDir in $badHomeDirs; do
            rm -r $badHomeDir
         done
     fi
   fi


   # clean share dirs #
   badShareDirs=""
   for sharePath in $unixSharePath/*; do
      if [ "$sharePath" -ot "/tmp/s4makeshareddirs_base_timestamp" ]; then
         badShareDirs="${badShareDirs} ${sharePath}"
      fi
   done

   if [ -n "$badShareDirs" ]; then
      echo " "
      echo "###############################################"
      echo " The following share directories seems not used "
      echo "###############################################"

      for badShareDir in $badShareDirs; do
         echo "$badShareDir"
      done

      if [ $(ask_yes_or_no "Would you like to delete them ?") == "yes" ]; then
         for badShareDir in $badShareDirs; do
            rm -r $badShareDir
         done
     fi
   fi


   # clean profiles dirs #
   #!!!!!!!!!!!!!!!!!!!!#

fi

#--------------------------------------------------------

###################
# clean if needed #
###################

# old user dirs #
if [ -n "$oldHomeDirs" ]; then
   for oldHomeDir in $oldHomeDirs; do
      changedUserName=$(basename $oldHomeDir)
      changedUserUid=$(stat -c "%u" $oldHomeDir)
      changedUserGid=$(stat -c "%g" $oldHomeDir)
      echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      echo "$oldHomeDir seems to be an old home dir."
      echo "But a new user with the same name now exist."
      if [ $(ask_yes_or_no "Would you like to delete the old files ? if not they will be given to the new user.") == "yes" ]; then
         rm -r $oldHomeDir
         mkdir -p $oldHomeDir
         chown $changedUserUid:$changedUserGid $oldHomeDir
         chmod 700 $oldHomeDir
      else
         chown -R $changedUserUid:$changedUserGid $oldHomeDir
         chmod 700 $oldHomeDir
         setfacl -R -b $oldHomeDir
         setfacl -R -k $oldHomeDir
      fi
      echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
   done
fi


# the others #
if [ "$deleteDirs" == "yes" ]; then

   # clean homes dirs #
   badHomeDirs=""
   for homePath in $unixHomePath/*; do
      if [ "$homePath" -ot "/tmp/s4makeshareddirs_base_timestamp" ]; then
         badHomeDirs="${badHomeDirs} ${homePath}"
      fi
   done

   if [ -n "$badHomeDirs" ]; then
      echo " "
      echo "###############################################"
      echo " The following home directories seems not used "
      echo "###############################################"

      for badHomeDir in $badHomeDirs; do
         echo "$badHomeDir"
      done

      if [ $(ask_yes_or_no "Would you like to delete them ?") == "yes" ]; then
         for badHomeDir in $badHomeDirs; do
            rm -r $badHomeDir
         done
     fi
   fi


   # clean share dirs #
   badShareDirs=""
   for sharePath in $unixSharePath/*; do
      if [ "$sharePath" -ot "/tmp/s4makeshareddirs_base_timestamp" ]; then
         badShareDirs="${badShareDirs} ${sharePath}"
      fi
   done

   if [ -n "$badShareDirs" ]; then
      echo " "
      echo "###############################################"
      echo " The following share directories seems not used "
      echo "###############################################"

      for badShareDir in $badShareDirs; do
         echo "$badShareDir"
      done

      if [ $(ask_yes_or_no "Would you like to delete them ?") == "yes" ]; then
         for badShareDir in $badShareDirs; do
            rm -r $badShareDir
         done
     fi
   fi


   # clean profiles dirs #
   #!!!!!!!!!!!!!!!!!!!!#

fi




