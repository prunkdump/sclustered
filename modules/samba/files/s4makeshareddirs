#! /usr/bin/perl -w
use strict;
use warnings;
use utf8;
use File::Basename;
use File::Path;
use File::Find;
use Getopt::Long;
use Sys::Hostname;
use Linux::ACL;

# output as utf8 #
binmode(STDOUT,':encoding(UTF-8)');

#########
# usage #
#########
sub displayUsage {
   my $callerProgram = basename($0);
   print("usage: $0 [-b baseClass] [-f] [-d]");
   print("   -b : update only dirs belonging to baseClass");
   print("   -f : force updating share permissions");
   print("   -d : delete unused dirs, asking for confirmation");
   exit(0);
}


######################
# check samba config #
######################
my $s4ConfFile = "/etc/samba/s4.conf";

# global vars #
my $baseDN;
my $baseUserDN;
my $baseShareDN;

my $baseUserGroup;
my $dfsPath;
my $unixHomePath;
my $homeShare;
my $unixProfilePath;
my $profileShare;
my $unixSharePath;
my $shareShare;

 

# open main configuration file #
open(my $sambaConf, "< $s4ConfFile") or die("Cannot read $s4ConfFile");

while( my $line = <$sambaConf> ) {

   chomp($line);
   
   # remove comments #
   if( $line =~ m/\#/ ) {
      if( $line =~ /(.*?)\#/ ) {
         $line = $1;
      }
   }

   # read DN #
   if ( $line =~ m/baseDN *= *\"(.*?)\"/ ) {
      $baseDN = $1;
   }
   elsif ( $line =~ m/baseUserDN *= *\"(.*?)\"/ ) {
      $baseUserDN = $1;
   }
   elsif ( $line =~ m/baseShareDN *= *\"(.*?)\"/ ) {
      $baseShareDN = $1;
   }

   # base user group #
   elsif ( $line =~ m/baseUserGroup *= *\"(.*?)\"/ ) {
      $baseUserGroup = $1;
   }

   # directory structure #
   elsif ( $line =~ m/dfsPath *= *\"(.*?)\"/ ) {
      $dfsPath = $1;
   }
   elsif( $line =~ m/unixHomePath *= *\"(.*?)\"/ ) {  
      $unixHomePath = $1;
   }
   elsif( $line =~ m/homeShare *= *\"(.*?)\"/ ) {
      $homeShare = $1;
   }
   elsif( $line =~ m/unixProfilePath *= *\"(.*?)\"/ ) {
      $unixProfilePath = $1;
   }
   elsif( $line =~ m/profileShare *= *\"(.*?)\"/ ) {
      $profileShare = $1;
   }
   elsif( $line =~ m/unixSharePath *= *\"(.*?)\"/ ) {
      $unixSharePath = $1;
   }
   elsif( $line =~ m/shareShare *= *\"(.*?)\"/ ) {
      $shareShare = $1;
   }
}
close($sambaConf);

# check global vars #
if( ! ( defined($baseDN) &&
        defined($baseUserDN) &&
        defined($baseShareDN) &&
        defined($baseUserGroup) &&
        defined($dfsPath) &&
        defined($unixHomePath) &&
        defined($homeShare) &&
        defined($unixProfilePath) &&
        defined($profileShare) &&
        defined($unixSharePath) &&
        defined($shareShare) ) ) {
   print("Cannot read global variables on $s4ConfFile\n");
   exit(1); 
}


###########################
# uid/gid mapping library #
###########################

# store name => id #
my %usersUid;
my %groupsGid;
#my %sharesGid;


# get all classic users uids #
#open(my $ldbCall, "-|", "s4ldbsearch $baseUserDN,$baseDN sub user '()' uidNumber");
#
#while( my $userInfoLine = <$ldbCall> ) {
#
#   chomp($userInfoLine);
#
#   my @userInfo = split(/\t/, $userInfoLine);
#   if( defined($userInfo[1]) ) {
#      if( $userInfo[0] =~ m/^CN=(.*?),/ ) {
#         my $userName = $1;
#         my $userUid = $userInfo[1];
#         $usersUid{$userName} = $userUid;
#      }
#      else {
#         print("Error getting user uid !\n");
#         exit(1);
#      }
#   }
#}
#
#close($ldbCall);

# get all classic groups gids #
#open($ldbCall, "-|", "s4ldbsearch $baseUserDN,$baseDN sub group '()' gidNumber");
#
#while( my $groupInfoLine = <$ldbCall> ) {
#
#   chomp($groupInfoLine);
#
#   my @groupInfo = split(/\t/, $groupInfoLine);
#   if( defined($groupInfo[1]) ) {
#      if( $groupInfo[0] =~ m/^CN=(.*?),/ ) {
#         my $groupName = $1;
#         my $groupGid = $groupInfo[1];
#         $groupsGid{$groupName} = $groupGid;
#      }
#      else {
#         print("Error getting group gid !\n");
#         exit(1);
#      }
#   }
#}
#
#close($ldbCall);


# get all classic share gids #
#open($ldbCall, "-|", "s4ldbsearch $baseShareDN,$baseDN sub user '()' gidNumber");
#
#while( my $shareInfoLine = <$ldbCall> ) {
#
#   chomp($shareInfoLine);
#
#   my @shareInfo = split(/\t/, $shareInfoLine);
#   if( defined($shareInfo[1]) ) {
#      if( $shareInfo[0] =~ m/^CN=(.*?),/ ) {
#         my $shareName = $1;
#         my $shareGid = $shareInfo[1];
#         $sharesGid{$shareName} = $shareGid;
#      }
#      else {
#         print("Error getting share gid !\n");
#         exit(1);
#      }
#   }
#}
#
#close($ldbCall);


sub getUserUid {

   # get params, the user name #
   my $userName = $_[0];

   # check if we have the uid #
   if( defined($usersUid{$userName}) {
      return $usersUid{$userName};
   }

   # try to find the user, we use baseDN as the user may be a system user #
   open(my $ldbCall, "-|", "s4ldbsearch $baseDN sub user \"(cn=$userName)\" uidNumber");

   my $userInfoLine;
   while( $userInfoLine = <$ldbCall> ) { }
   close($ldbCall)

   # check if user found #
   if( $? != 0 ) {
      print("User $userName UID not found ! Check AD database for errors !\");
      exit(1);
   } else {

      # save the result #
      chomp($userInfoLine);
      my $userUid = (split(/\t/, $userInfoLine))[1];
      $usersUid{$userName} = $userUid;
      return $userUid;
   }
}


sub getGroupGid {

   # get params, the group name #
   my $groupName = $_[0];

   # check if we have the gid #
   if( defined($groupsGid{$groupName}) {
      return $groupsGid{$groupName};
   }

   # try to find the group, we use baseDN as this may be a system group #
   open(my $ldbCall, "-|", "s4ldbsearch $baseDN sub group \"(cn=$groupName)\" gidNumber");

   my $groupInfoLine;
   while( $groupInfoLine = <$ldbCall> ) { }
   close($ldbCall)

   # check if group found #
   if( $? != 0 ) {
      print("Group $groupName GID not found ! Check AD database for errors !\");
      exit(1);
   } else {
      # save the result #
      chomp($groupInfoLine);
      my $groupGid = (split(/\t/, $groupInfoLine))[1];
      $groupsGid{$groupName} = $groupGid;
      return $groupGid;
   }
}


sub setFileAcl {

   # get params, the file, the mod, the acls #
   my ($filePath, $fileMod, $fileAclString) = @_;

   # hash to fill to set ACLs #
   my %fileAcls;
   my %defaultFileAcls;

   # check if the file exist #
   if( ! -e "$filePath" ) {
      print("Attempted to change the ACLs of a non existing file !\n");
      exit(1);
   }

   ###############
   # analyse mod #
   ###############

   # check mod #
   if( ! ($fileMod =~ m/^[0-7]{3,4}$/) ) {
      print("Bad mod used : $fileMod !\n");
      exit(1);
   }

   # remove sticky, not used in acls #
   if( length($fileMod) == 4 ) {
      $fileMod = substr($fileMod, 1);
   }

   # check mod user #
   my @modTargets = ('uperm', 'gperm', 'other');
   foreach my $targetIdx (0..$#modTarget) {
 
      my $modTarget = $modTargets[$targetIdx];

      # read mod number #
      my $mod = substr($fileMod, $targetIdx, 1);
      
      # r permission #
      if( $mod & 4 ) {
         $fileAcls{$modTarget}{'r'} = 1;
      } else {
         $fileAcls{$modTarget}{'r'} = 0;
      }

      # w permission #
      if( $mod & 2 ) {
         $fileAcls{$modTarget}{'w'} = 1;
      } else {
         $fileAcls{$modTarget}{'w'} = 0;
      }

      # x permission #
      if( $mod & 1 ) {
         $fileAcls{$modTarget}{'x'} = 1;
      } else {
         $fileAcls{$modTarget}{'x'} = 0;
      }
   }

   ##############
   # check acls #
   ##############

   while( length($fileAclString) ) {

      # check default #
      my $alcRef;
      if( $fileAclString =~ m/^d:/ ) {
         $alcRef = \%defaultFileAcls;
         $fileAclString = substr($fileAclString, 2);
      } else {
         $alcRef = \%fileAcls
      }

      # read acl #
      if( $fileAclString =~ m/^(u|user|g|group|m|mask|o|other):(.*?):([rwx]{0,3})(,|$)/ ) {

         my $aclType = $1;
         my $aclTarget = $2;
         my $aclRights = $3;
         my $aclID;

         # check type #
         if( $aclType eq "u" ) {
            $aclType = "user";
         }
         elsif( $aclType eq "g" ) {
            $aclType = "group";
         }
         elsif( $aclType eq "m" ) {
            $aclType = "mask";
         }
         elsif( $aclType eq "o" ) {
            $aclType = "other";
         }

         # get id if needed #
         if( $aclType eq "user" ) {
            $aclID = getUserUid($aclTarget);
         }
         elsif( $aclType eq "group" ) {
            $aclID = getGroupGid($aclTarget);
         }

         # save #
         if( $aclType eq "user" || $aclType eq "group" ) {

            if( $aclRights =~ m/r/ ) {
               $alcRef->{$aclType}{$aclID}{'r'} = 1;
            } else {
               $alcRef->{$aclType}{$aclID}{'r'} = 0;
            }

            if( $aclRights =~ m/w/ ) {
               $alcRef->{$aclType}{$aclID}{'w'} = 1;
            } else {
               $alcRef->{$aclType}{$aclID}{'w'} = 0;
            }

            if( $aclRights =~ m/x/ ) {
               $alcRef->{$aclType}{$aclID}{'x'} = 1;
            } else {
               $alcRef->{$aclType}{$aclID}{'x'} = 0;
            }

         } else {

            if( $aclRights =~ m/r/ ) {
               $alcRef->{$aclType}{'r'} = 1;
            } else {
               $alcRef->{$aclType}{'r'} = 0;
            }

            if( $aclRights =~ m/w/ ) {
               $alcRef->{$aclType}{'w'} = 1;
            } else {
               $alcRef->{$aclType}{'w'} = 0;
            }

            if( $aclRights =~ m/x/ ) {
               $alcRef->{$aclType}{'x'} = 1;
            } else {
               $alcRef->{$aclType}{'x'} = 0;
            }
         }

         # next #
         $fileAclString = substr($fileAclString, length("$1:$2:$3$4"));

      } else {
         print("Bad ACL string : $fileAclString\n");
         exit(1); 
      }
   }

   # ok, acl read #
   # now apply #
   setfacl($filePath, %fileAcls, %defaultFileAcls);
}


###############
# ask library #
###############

sub askYesOrNo {

   # get params, the questions #
   my $question = $_[0];

   # ask #
   while( 1 ) {
      print("$question ([y]es or [N]o): ");
      my $rep = <>;
      if( $rep =~ m/^y(es|)$/ ) {
         return 'yes';
      elsif( $rep m=~ /^no?$/ ) {
         return 'no';
      }
   }
}


##############
# parse args #
##############

# the options #
my $optBaseClass;
my $optForce;
my $optDelete;

Getopt::Long::Configure("bundling","no_ignore_case");
GetOptions("b|base-class" => \$optBaseClass,
           "f|force" => \$optForce,
           "d|delete" => \$optDelete) 
          or displayUsage();

# check args #
if( @ARGV != 0 ){
   displayUsage();
}


# check the delete option #
# can't be combined with base class as we touch each file #
# to check unused #
if ( defined($optBaseClass) && defined($optDelete) ) {
   print("The -b and -d options can't be used together.\n");
   exit(1);
}


# get the base class #
my $baseClassName;

if ( ! defined($optBaseClass) ) {
   $baseClassName = substr($baseUserDN, length('OU='));
} else {
   $baseClassName = $optBaseClass;
}

# check the class exist and get info #
my $baseClassGroup;
my $baseClassUserDN;
my $baseClassShareDN;

open(my $classCheckCall, "-|", "s4classcheck $baseClassName");
while( my $classInfoLine = <$classCheckCall> ) {

   chomp($classInfoLine);

   if( $classInfoLine =~ m/^Class group: (.*)$/ ) {
      $baseClassGroup = $1;
   }
   elsif( $classInfoLine =~ m/^Class DN: (.*)$/ ) {
      $baseClassUserDN = $1;
   }
   elsif( $classInfoLine =~ m/^Class share DN: (.*)$/ ) {
      $baseClassShareDN = $1;
   }
}

close($classCheckCall);
if( $? != 0 ) {
   print("Cannot find base class $baseClassName !\n");
   exit(1);
}

###################
# get system vars #
###################

# get hostname #
my $serverHostname = hostname;

# get time #
my $baseTimestamp = time();

# To check unused dirs later #
# -> create of update dir timestamp #
# -> return if dir rights must be set #
sub touchDir {
   if ( -e $1 ) {
      utime(undef, undef, $1);
      if ( defined($optForce) ) {
         return 1;
      } else {
         return 0;
      }
   } else {
      make_path($1);
      return 1;
   }
}


####################
# create user dirs #
####################

# save remote servers #
my %remoteHomeServers;

# home directories that need to be deleted later #
my @oldHomeDirs;

# get all users #
open($ldbCall, "-|", "s4ldbsearch $baseClassUserDN,$baseDN sub user '()' cn unixHomeDirectory uidNumber gidNumber");

while( my $userInfoLine = <$ldbCall> ) {

   chomp($userInfoLine);

   # get user info #
   my ($userDn, $userName, $userHomeDirectory, $userUid, $userGid) = split(/\t/, $userInfoLine);

   # get user class group #
   my $userClassGroup;
   if( $userDn =~ m/^CN=$userCn,OU=(.*?),/ ) {
      $userClassGroup = lc($1);
   } else {
      print("Cannot determine user $userCn class group !\n");
      exit(1);
   }

   # get user server #
   my $userServer;
   if( $userHomeDirectory =~ m/\/dnfs\/$homeShare\/(.*)\/$userName ) {
      $userServer = $1;
   } else {
      print("Cannot determine user $userCn home server !\n");
      exit(1);
   }

   ####################
   # create user dirs #
   ####################

   # make class share directories #
   touchDir("/srv/nfs4/$shareShare/$userClassGroup");
   touchDir("$dfsPath/$userClassGroup");

   # if user on current server create user directory #
   if ( $userServer eq $serverHostname ) {

      #############################
      # check some specials cases #
      #############################
      if ( -e $unixHomePath/$userName ) {

         # check if the uid is correct #
         my ($currentDirUid, $currentDirGid) = (stat($unixHomePath/$userName))[4,5];

         if ( $currentDirUid != $userUid) {

            # bad uid ! this must be an old user dir, delete or restore later #
            push @oldHomeDirs, $unixHomePath/$userName;
            chown($userUid, $userGid, $unixHomePath/$userName);
            system("setfacl -bk $unixHomePath/$userName");
            chmod(0700, $unixHomePath/$userName);

         } else {

            # check if the gid is correct #
            if ( $currentDirGid != $userGid ) {

                # bad gid ! may the user's class have changed #
                print("Seems the ${userName}'s class have changed, restoring rights ...\n");
                chown($userUid, $userGid, $unixHomePath/$userName);
                system("setfacl -bk $unixHomePath/$userName");
                chmod(0700, $unixHomePath/$userName);
            }
         }
      }      

      # touch the directory, and update rights if needed #
      if( touchDir($unixHomePath/$userName) ) {

         chown($userUid, $userGid, $unixHomePath/$userName);
         system("setfacl -bk $unixHomePath/$userName");
         chmod(0700, $unixHomePath/$userName);
      }
   }

   # if the user is not on this server, add to the remote servers list #
   else {
      $remoteHomeServers{$userServer} = 1;
   }
}

close($ldbCall);


##################
# get nfs params #
##################

# get template #
open(my $exportTemplate, "<", "/etc/exports.d/export.template") or die("Cannot find nfs export template !\n");
my $shareNfsTemplate = <$exportTemplate>;
chomp($shareNfsTemplate);
close($exportTemplate);

# extract params #
my $shareNFSParams = (split(" ", $shareNfsTemplate))[1];


##################################################################
# create nfs home server redirection                             #
# (not needed for dfs as the server is written in the home share # 
##################################################################
foreach my $remoteHomeServer (keys @remoteHomeServers) {

   my $serverHomeShareDir="/srv/nfs4/$homeShare/$remoteHomeServer";

   # create server redirection directory #
   touchDir($serverHomeShareDir)
   chown(0, $baseUserGroup, $serverHomeShareDir);
   chmod(0755, $serverHomeShareDir);

   # create systemd unit to bind the directory to itself, needed for nfs referrals #
   my $systemdUnitName="srv-nfs4-$homeShare-$remoteHomeServer.mount";
   open(my $systemdUnit, ">", $systemdUnitName) or die "Can't open $systemdUnitName !";

   print $systemdUnit 
"[Unit]

[Mount]
What=$serverHomeShareDir
Where=$serverHomeShareDir
Type=none
Options=bind

[Install]
WantedBy=multi-user.target
";

   close($systemdUnit);

   system("systemctl enable $systemdUnitName");
   system("systemctl start $systemdUnitName");

   ###########################
   # create nfs4 redirection #
   ###########################

   # add new referral params #
   $shareNFSParamsWithReferral = substr($shareNFSParams, 0, -1) . ",refer=/$homeShare/$remoteHomeServer@$remoteHomeServer)");
   
   # create new share #
   open($nfsShareExport, ">", "/etc/exports.d/home-redirection-$remoteHomeServer.exports");
   print $nfsShareExport "$serverHomeShareDir $shareNFSParamsWithReferral\n";
   close($nfsShareExport);

}


######################
# create shares dirs #
######################

# get all shares #
open($ldbCall, "-|", "s4ldbsearch $baseClassShareDN,$baseDN sub user '()' cn givenName description unixHomeDirectory memberOf");

while( my $shareInfoLine = <$ldbCall> ) {

   chomp($shareInfoLine);

   # get share info #
   # givenName -> show name
   # description -> rights : owner,mod,acls
   # unixHomeDirectory -> server 
   # memberOf -> the classes that see the share  
   my ($shareDN, $shareName, $shareShowName, $shareRights, $shareServer, $shareShowClassesList) = split(/\t/, $shareInfoLine);

   # get share class group and DN #
   my $shareClassName;
   my $shareClassGroup;
   my $shareClassGroupDN;

   if( $shareDN =~ m/CN=$shareName,OU=(.*?),(.*),$baseShareDN,$baseDN$/ ) {
      $shareClassName = $1;
      $userClassGroup = lc($shareClassName);
      $shareClassGroupDN = "CN=$userClassGroup,OU=$shareClassName,$2,$baseUserDN,$baseDN";
   } else {
      print("Cannot determine the share $shareName class group !\n");
      exit(1);
   }

   # get share class display name #
   my $shareClassDisplayName;

   open(my $searchGroupCall , "-|", "s4ldbsearch $shareClassGroupDN base group '()' displayName");
   my $shareClassGroupInfoLine = <$searchGroupCall>;
   close($searchGroupCall);

   if( $? != 0 ) {
      print("Cannot find class $shareClassName group $shareClassGroupDN !\n");
      exit(1);
   }

   chomp($shareClassGroupInfoLine);
   my $shareClassDisplayName = (split(/\t/, <$searchGroupCall>))[1];

   # get share show classes #
   my @shareShowClasses = split(/|/, $shareShowClassesList);


   ##############
   # get rights #
   ##############

   my ($shareOwner,$shareMod,$shareAcls) = split(/,/, $shareRights);
   my ($shareOwnerUser, $shareOwnerGroup) = split(/:/, $shareOwner);

   my $shareOwnerUID;
   if( $shareOwnerUser eq 'root' ) {
      $shareOwnerUID = 0;
   } else {
      $shareOwnerUID = getUserUid($shareOwnerUser);
      if( $shareOwnerUID < 0 ) {
         print("Cannot find user $shareOwnerUser UID !\n");
         exit(1);
      } 
   }

   my $shareOwnerGID;
   if( $shareOwnerGroup eq 'root' ) {
      $shareOwnerGID = 0;
   } else {
      $shareOwnerGID = getGroupGid($shareOwnerGroup);
      if( $shareOwnerGID < 0 ) {
         print("Cannot find group $shareOwnerGroup GID !\n");
         exit(1); 
      }
   }


   ############################
   # create share directories #
   ############################
   if( $shareServer eq $serverHostname ) {

      # check share directory #
      if( touchDir($unixSharePath/$shareName) ) {

         chown($shareOwnerUID, $shareOwnerGID, $unixSharePath/$shareName)
         chmod($shareMod, $unixSharePath/$shareName);
         system("setfacl -bk $unixSharePath/$shareName");
         if( length($shareAcls) ) {
            setFileAcl($unixSharePath/$shareName, $shareMod, $shareAcls);
         }
      }
   }


   ########################
   # create nfs/dfs links #
   ########################
   open(my $shareExport, ">", "/etc/exports.d/$shareName.exports");

   my $nfsRoot = "/srv/nfs4/$shareShare";
   my $sambaDFSRoot = "$dfsPath";

   foreach my $showClass (@shareShowClasses) {

      my $showClassGroup = lc($showClass);

      # make dirs #
      # the nfs one and samba dfs one # 
      my $shareShowDir = "$nfsRoot/$showClassGroup/$shareClassDisplayName/$shareShowName";
      my $sambaShareShowDir = "$sambaDFSRoot/$showClassGroup/$shareClassDisplayName/$shareShowName";

      touchDir($shareShowDir);
      touchDir($sambaShareShowDir);

      # nfs share #
      my $shareNfs = "$shareShowDir $shareNFSParams"
      my $systemdUnitName = $shareShowDir;
      $systemdUnitName =~ s|/|-|g;
      
      # add referral if needed #
      my $mountTarget;
      if( $shareServer eq $serverHostname ) {
         $mountTarget = "$unixSharePath/$shareName";
      } else {
         # bind mount to itself #
         $mountTarget = $shareShowDir;
         $shareNfs = substr($shareNfs, 0, -1) . ",refer=/$shareShare/$showClassGroup/$shareClassDisplayName/$shareShowName@$shareServer)"; 
      }

      # write unit file #
      open(my $unitFile, ">", "/lib/systemd/system/$systemdUnitName");
      print $unitFile
"[Unit]

[Mount]
What=$mountTarget
Where=$shareShowDir
Type=none
Options=bind

[Install]
WantedBy=multi-user.target
";
      close($unitFile);

      system("systemctl enable $systemdUnitName");
      system("systemctl start $systemdUnitName");
   
      # add show export #
      print $shareExport "$shareNfs\n";

      # dfs share #
      symlink("msdfs:$shareServer\\$shareShare\\$shareName", $sambaShareShowDir); 
   }

  close($shareExport);
  
}
close($ldbCall);

# reload nfs #
system("/usr/sbin/exportfs -ra");


###################
# clean if needed #
###################

# old user dirs #
foreach my $oldHomeDir (@oldHomeDirs) {

   my $changedUserName = basename($oldHomeDir);
   my ($changedUserUid, $changedUserGid) = (stat($oldHomeDir))[4,5];
   print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
   print("$oldHomeDir seems to be an old home dir.\n");
   print("But a new user with the same name now exist.\n");
   if( askYesOrNo("Would you like to delete the old files ? if not they will be given to the new user.") eq "yes" ) {
      rmtree($oldHomeDir, { safe => 1 });
      touchDir($oldHomeDir);
      chown($changedUserUid, $changedUserGid, $oldHomeDir);
      chmod(0700, $oldHomeDir);
   } else {

      # recursive chown #
      chown($changedUserUid, $changedUserGid, $oldHomeDir);
      chmod(0700,$oldHomeDir);
      system("setfacl -R -bk $oldHomeDir");
      
      find( sub {
         chown($changedUserUid, $changedUserGid, $_);
      }, $oldHomeDir );
         
   }
   print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
}


# the others dirs #
if( $optDelete ) {

   # clean homes dirs #
   my @badHomeDirs;
   
   # check all homes #
   foreach my $homePath (<$unixHomePath/*>) {

      # check if the directory is older #
      if ( (stat($homePath))[9] < $baseTimestamp ) {
         push @badHomeDirs, $homePath;
      }
   }

   if( @badHomeDirs ) {

      print("\n");
      print("###############################################\n");
      print(" The following home directories seems not used \n");
      print("###############################################\n");

      foreach my $badHomeDir (@badHomeDirs) {
         print("$badHomeDir\n");
      }

      if( askYesOrNo("Would you like to delete them ?") eq "yes") {
         foreach my $badHomeDir (@badHomeDirs) {
            rmtree($badHomeDir, { safe => 1 });
         }
      }
   }

   # clean share dirs #
   my @badShareDirs;

   # check all shares #
   foreach my $sharePath (<$unixSharePath/*>) {

      # check if the directory is older #
      if ( (stat($sharePath))[9] < $baseTimestamp ) {
         push @badShareDirs, $sharePath;
      }
   }

   if( @badShareDirs ) {

      print("\n");
      print("################################################\n");
      print(" The following share directories seems not used \n");
      print("################################################\n");

      foreach my $badShareDir (@badShareDirs) {
         print("$badShareDir\n");
      }

      if( askYesOrNo("Would you like to delete them ?") eq "yes") {
         foreach my $badShareDir (@badShareDirs) {
            rmtree($badShareDir, { safe => 1 });
         }
      }
   }

   # clean profiles dirs #
   #!!!!!!!!!!!!!!!!!!!!#

}

